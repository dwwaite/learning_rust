# Overview

Starting to get a bit more complex, looking at some of the movement rules, and implementing `struct`s, which are the `rust` equivalent of classes.

* Moving and scope
  * [moving.rs](../2.structs_enums/moving.rs)
  * [scope.rs](../2.structs_enums/scope.rs)
* Structs, tuple, generics, and enums
  * [structs_tuples.rs](../2.structs_enums/structs_tuples.rs)
  * [expanding_structs.rs](../2.structs_enums/expanding_structs.rs)
    * This does not make use of the [lifetime information in the tutorial](https://stevedonovan.github.io/rust-gentle-intro/2-structs-enums-lifetimes.html#lifetimes-start-to-bite).
  * [traits.rs](../2.structs_enums/traits.rs)
  * [generics.rs](../2.structs_enums/generics.rs)
  * [enums.rs](../2.structs_enums/enums.rs)
  * [more_matching.rs](../2.structs_enums/more_matching.rs)
* Closures
  * [closures.rs](../2.structs_enums/closures.rs)
    * (This does not make use of the [mutate section of the tutorial](https://stevedonovan.github.io/rust-gentle-intro/2-structs-enums-lifetimes.html#closures))
* Iterators and dynamic data boxing
  * [iterator_types.rs](../2.structs_enums/iterator_types.rs)
  * [dynamic_data.rs](../2.structs_enums/dynamic_data.rs)
    * (This closes off skipping the part about using a [generic within a struct](https://stevedonovan.github.io/rust-gentle-intro/2-structs-enums-lifetimes.html#generic-structs) as this is too niche of a use case for me)

Done. Over to projects!
